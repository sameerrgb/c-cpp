Given a linked list and a key ‘X‘ in, the task is to check if X is present in the linked list or
not.
Examples:
Input: 14->21->11->30->10, X = 14
Output: Yes
Explanation: 14 is present in the linked list.
Input: 6->21->17->30->10->8, X = 13
Output: No

#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the linked list
struct Node {
    int data;   // Value stored in the node
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the beginning of the linked list
// This is a helper function to easily build the example linked lists.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // Move the head to point to the new node
    (*head_ref) = new_node;
}

// Function to check if a key X is present in the linked list
// head: Pointer to the head of the linked list
// x: The key value to search for
bool search(Node* head, int x) {
    // Start from the head of the linked list
    Node* current = head;

    // Traverse the linked list
    while (current != nullptr) {
        // If the current node's data matches the key X
        if (current->data == x) {
            return true; // Key found, return true
        }
        // Move to the next node
        current = current->next;
    }

    // If the loop finishes without finding the key, it means X is not present
    return false; // Key not found, return false
}

// Helper function to print the linked list elements
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << " ";
        node = node->next;
    }
    std::cout << std::endl;
}

// Helper function to delete the linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
}


// Main function to demonstrate the linked list search
int main() {
    // Example 1: Linked list 14->21->11->30->10, X = 14
    Node* head1 = nullptr; // Initialize an empty linked list

    // Build the linked list (pushing to front, so order is reversed initially)
    push(&head1, 10);
    push(&head1, 30);
    push(&head1, 11);
    push(&head1, 21);
    push(&head1, 14); // Head is now 14

    int key1 = 14;
    std::cout << "Linked List 1: ";
    printList(head1);
    std::cout << "Key to search: " << key1 << std::endl;

    if (search(head1, key1)) {
        std::cout << "Output: Yes" << std::endl;
    } else {
        std::cout << "Output: No" << std::endl;
    }

    std::cout << "--------------------" << std::endl;

    // Example 2: Linked list 6->21->17->30->10->8, X = 13
    Node* head2 = nullptr; // Initialize another empty linked list

    // Build the linked list
    push(&head2, 8);
    push(&head2, 10);
    push(&head2, 30);
    push(&head2, 17);
    push(&head2, 21);
    push(&head2, 6); // Head is now 6

    int key2 = 13;
    std::cout << "Linked List 2: ";
    printList(head2);
    std::cout << "Key to search: " << key2 << std::endl;

    if (search(head2, key2)) {
        std::cout << "Output: Yes" << std::endl;
    } else {
        std::cout << "Output: No" << std::endl;
    }

    // Clean up allocated memory
    deleteList(&head1);
    deleteList(&head2);

    return 0; // Indicate successful program execution
}






Write a function that takes a list sorted in non-decreasing order and deletes any
duplicate nodes from the list. The list should only be traversed once.
For example if the linked list is 11->11->11->21->43->43->60 then removeDuplicates()
should convert the list to 11->21->43->60.

#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the linked list
struct Node {
    int data;   // Value stored in the node
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the beginning of the linked list
// This is a helper function to easily build the example linked lists.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // Move the head to point to the new node
    (*head_ref) = new_node;
}

// Function to remove duplicate nodes from a sorted linked list
// The list is traversed only once.
void removeDuplicates(Node* head) {
    // If the list is empty, there's nothing to do
    if (head == nullptr) {
        return;
    }

    // Start with the current node as the head
    Node* current = head;

    // Traverse the list until the current node is null or the next node is null
    // We need to look ahead to compare the current node with the next one.
    while (current != nullptr && current->next != nullptr) {
        // If the data of the current node is the same as the data of the next node (duplicate found)
        if (current->data == current->next->data) {
            // Store the duplicate node in a temporary pointer
            Node* duplicate_node = current->next;

            // Skip the duplicate node by linking the current node to the node after the duplicate
            current->next = duplicate_node->next;

            // Delete the duplicate node to free up memory
            delete duplicate_node;

            // Note: We do NOT move 'current' forward here because the new 'current->next'
            // might also be a duplicate of the current node.
        }
        // If the data of the current node is different from the data of the next node
        // (no duplicate with the next element), move to the next node.
        else {
            current = current->next;
        }
    }
}

// Helper function to print the linked list elements
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << (node->next == nullptr ? "" : "->");
        node = node->next;
    }
    std::cout << std::endl;
}

// Helper function to delete the linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
}


// Main function to demonstrate the removeDuplicates functionality
int main() {
    // Create the example linked list: 11->11->11->21->43->43->60
    Node* head = nullptr; // Initialize an empty linked list

    // Build the linked list (pushing to front, so order is reversed initially)
    push(&head, 60);
    push(&head, 43);
    push(&head, 43);
    push(&head, 21);
    push(&head, 11);
    push(&head, 11);
    push(&head, 11); // Head is now 11

    std::cout << "Original Linked List: ";
    printList(head);

    // Remove duplicate nodes
    removeDuplicates(head);

    std::cout << "Linked List after removing duplicates: ";
    printList(head);

    // Clean up allocated memory
    deleteList(&head);

    return 0; // Indicate successful program execution
}





Given a singly linked list, write a function to swap elements pairwise.
Input : 1->2->3->4->5->6->NULL
Output : 2->1->4->3->6->5->NULL
Input : 1->2->3->4->5->NULL
Output : 2->1->4->3->5->NULL
Input : 1->NULL
Output : 1->NULL

#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the linked list
struct Node {
    int data;   // Value stored in the node
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the beginning of the linked list
// This is a helper function to easily build the example linked lists.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // Move the head to point to the new node
    (*head_ref) = new_node;
}

// Function to swap nodes pairwise in a linked list
Node* swapPairs(Node* head) {
    // Base case: If the list is empty or has only one node, no swapping needed
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Create a dummy node to handle the case where the head needs to be swapped
    // The dummy node's next pointer will eventually point to the new head of the list
    Node* dummy = new Node(0); // Dummy node with arbitrary data (0)
    dummy->next = head;        // Link the dummy node to the original head

    // 'prev' pointer keeps track of the node before the pair being swapped
    Node* prev = dummy;

    // 'first' and 'second' pointers point to the two nodes in the current pair
    Node* first = head;
    Node* second = head->next;

    // Traverse the list in pairs
    while (first != nullptr && second != nullptr) {
        // Perform the swap:
        // 1. Link the previous node's next to the second node
        prev->next = second;

        // 2. Link the first node's next to the node after the second node
        first->next = second->next;

        // 3. Link the second node's next to the first node
        second->next = first;

        // Move pointers forward for the next pair:
        // 'prev' becomes the first node of the just-swapped pair
        prev = first;

        // 'first' becomes the node after the current 'prev' (start of the next pair)
        first = prev->next;

        // 'second' becomes the node after the new 'first'
        if (first != nullptr) {
            second = first->next;
        } else {
            second = nullptr; // If 'first' is null, there's no 'second'
        }
    }

    // The new head of the list is the node after the dummy node
    Node* new_head = dummy->next;

    // Delete the dummy node to free memory
    delete dummy;

    // Return the new head of the modified linked list
    return new_head;
}

// Helper function to print the linked list elements
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << (node->next == nullptr ? "" : "->");
        node = node->next;
    }
    std::cout << std::endl;
}

// Helper function to delete the linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
}


// Main function to demonstrate the swapPairs functionality
int main() {
    // Example 1: Input : 1->2->3->4->5->6->NULL
    Node* head1 = nullptr;
    push(&head1, 6);
    push(&head1, 5);
    push(&head1, 4);
    push(&head1, 3);
    push(&head1, 2);
    push(&head1, 1);

    std::cout << "Original Linked List 1: ";
    printList(head1);

    head1 = swapPairs(head1);

    std::cout << "Linked List 1 after swapping pairs: ";
    printList(head1);

    std::cout << "--------------------" << std::endl;

    // Example 2: Input : 1->2->3->4->5->NULL
    Node* head2 = nullptr;
    push(&head2, 5);
    push(&head2, 4);
    push(&head2, 3);
    push(&head2, 2);
    push(&head2, 1);

    std::cout << "Original Linked List 2: ";
    printList(head2);

    head2 = swapPairs(head2);

    std::cout << "Linked List 2 after swapping pairs: ";
    printList(head2);

    std::cout << "--------------------" << std::endl;

    // Example 3: Input : 1->NULL
    Node* head3 = nullptr;
    push(&head3, 1);

    std::cout << "Original Linked List 3: ";
    printList(head3);

    head3 = swapPairs(head3);

    std::cout << "Linked List 3 after swapping pairs: ";
    printList(head3);

    std::cout << "--------------------" << std::endl;

    // Example 4: Empty list
    Node* head4 = nullptr;
    std::cout << "Original Linked List 4 (empty): ";
    printList(head4);
    head4 = swapPairs(head4);
    std::cout << "Linked List 4 after swapping pairs: ";
    printList(head4);
    std::cout << "--------------------" << std::endl;


    // Clean up allocated memory
    deleteList(&head1);
    deleteList(&head2);
    deleteList(&head3);
    deleteList(&head4); // Should be nullptr, but deleteList handles it

    return 0; // Indicate successful program execution
}





Write a function that moves the last node to the front in a given Singly Linked List.
Examples:
Input: 1->2->3->4->5
Output: 5->1->2->3->4
Input: 3->8->1->5->7->12
Output: 12->3->8->1->5->7

#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the linked list
struct Node {
    int data;   // Value stored in the node
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the beginning of the linked list
// This is a helper function to easily build the example linked lists.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // Move the head to point to the new node
    (*head_ref) = new_node;
}

// Function to move the last node of a singly linked list to the front
// Returns the new head of the modified linked list.
Node* moveToFront(Node* head) {
    // Handle edge cases:
    // 1. If the list is empty (head is nullptr)
    // 2. If the list has only one node (head->next is nullptr)
    // In both cases, no change is needed, return the original head.
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Traverse the list to find the last node and the second-to-last node
    Node* current = head;
    Node* second_last = nullptr; // Pointer to the node before the last one

    // Iterate until 'current' is the last node (current->next is nullptr)
    while (current->next != nullptr) {
        second_last = current; // Keep track of the node before 'current'
        current = current->next; // Move to the next node
    }

    // At this point:
    // 'current' points to the last node.
    // 'second_last' points to the node before the last node.

    // 1. Make the second-to-last node's next point to nullptr
    // This effectively detaches the last node and makes 'second_last' the new last node.
    second_last->next = nullptr;

    // 2. Make the original last node's next point to the original head
    // This links the detached last node to the beginning of the rest of the list.
    current->next = head;

    // 3. Update the head of the list to be the original last node
    // The original last node is now the new front of the list.
    head = current;

    // Return the new head of the modified linked list
    return head;
}

// Helper function to print the linked list elements
void printList(Node* node) {
    while (node != nullptr) {
        std::cout << node->data << (node->next == nullptr ? "" : "->");
        node = node->next;
    }
    std::cout << std::endl;
}

// Helper function to delete the linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
}


// Main function to demonstrate the moveToFront functionality
int main() {
    // Example 1: Input: 1->2->3->4->5
    Node* head1 = nullptr; // Initialize an empty linked list

    // Build the linked list (pushing to front, so order is reversed initially)
    push(&head1, 5);
    push(&head1, 4);
    push(&head1, 3);
    push(&head1, 2);
    push(&head1, 1); // Head is now 1

    std::cout << "Original Linked List 1: ";
    printList(head1);

    // Move the last node to the front
    head1 = moveToFront(head1);

    std::cout << "Linked List 1 after moving last to front: ";
    printList(head1);

    std::cout << "--------------------" << std::endl;

    // Example 2: Input: 3->8->1->5->7->12
    Node* head2 = nullptr; // Initialize another empty linked list

    // Build the linked list
    push(&head2, 12);
    push(&head2, 7);
    push(&head2, 5);
    push(&head2, 1);
    push(&head2, 8);
    push(&head2, 3); // Head is now 3

    std::cout << "Original Linked List 2: ";
    printList(head2);

    // Move the last node to the front
    head2 = moveToFront(head2);

    std::cout << "Linked List 2 after moving last to front: ";
    printList(head2);

    std::cout << "--------------------" << std::endl;

    // Example 3: List with one node
    Node* head3 = nullptr;
    push(&head3, 99);
    std::cout << "Original Linked List 3 (single node): ";
    printList(head3);
    head3 = moveToFront(head3); // Should not change
    std::cout << "Linked List 3 after moving last to front: ";
    printList(head3);
    std::cout << "--------------------" << std::endl;

    // Example 4: Empty list
    Node* head4 = nullptr;
    std::cout << "Original Linked List 4 (empty): ";
    printList(head4);
    head4 = moveToFront(head4); // Should not change
    std::cout << "Linked List 4 after moving last to front: ";
    printList(head4);
    std::cout << "--------------------" << std::endl;


    // Clean up allocated memory
    deleteList(&head1);
    deleteList(&head2);
    deleteList(&head3);
    deleteList(&head4); // Should be nullptr, but deleteList handles it

    return 0; // Indicate successful program execution
}





Given a linked list, check if the linked list has a loop or not.
#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the linked list
struct Node {
    int data;   // Value stored in the node
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a new node at the beginning of the linked list
// This is a helper function to easily build linked lists.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // Move the head to point to the new node
    (*head_ref) = new_node;
}

// Function to detect if a linked list has a loop using Floyd's Cycle-Finding Algorithm
// head: Pointer to the head of the linked list
bool hasLoop(Node* head) {
    // Initialize two pointers, slow_ptr and fast_ptr, at the head of the list
    Node* slow_ptr = head;
    Node* fast_ptr = head;

    // Traverse the list with two pointers:
    // slow_ptr moves one step at a time.
    // fast_ptr moves two steps at a time.
    // If there is a loop, the fast_ptr will eventually catch up to the slow_ptr.
    while (fast_ptr != nullptr && fast_ptr->next != nullptr) {
        slow_ptr = slow_ptr->next;      // Move slow_ptr one step
        fast_ptr = fast_ptr->next->next; // Move fast_ptr two steps

        // If slow_ptr and fast_ptr meet, it means there is a loop
        if (slow_ptr == fast_ptr) {
            return true; // Loop detected
        }
    }

    // If the loop finishes without the pointers meeting, it means there is no loop
    // This happens when fast_ptr reaches the end of the list (nullptr)
    // or when fast_ptr->next is nullptr (fast_ptr is the last node).
    return false; // No loop detected
}

// Helper function to print the linked list elements (up to a certain number of nodes
// to avoid infinite loops on lists with loops).
void printList(Node* head, int limit = 20) {
    Node* current = head;
    int count = 0;
    while (current != nullptr && count < limit) {
        std::cout << current->data << (current->next == nullptr || count == limit - 1 ? "" : "->");
        current = current->next;
        count++;
    }
    if (count == limit && current != nullptr) {
        std::cout << "..." << std::endl; // Indicate that the list might continue (likely a loop)
    } else {
         std::cout << std::endl;
    }
}


// Helper function to delete a linked list (handles lists without loops)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
}

// NOTE: Deleting a linked list with a loop requires a different approach
// to avoid infinite loops and memory leaks. For simplicity in this example,
// we will only delete lists that are confirmed to not have loops.
// If you need to delete a list with a loop, you would first detect the loop,
// find the starting node of the loop, break the loop, and then traverse and delete.


// Main function to demonstrate the hasLoop functionality
int main() {
    // Example 1: Linked list without a loop
    Node* head1 = nullptr; // Initialize an empty linked list
    push(&head1, 5);
    push(&head1, 4);
    push(&head1, 3);
    push(&head1, 2);
    push(&head1, 1); // List: 1->2->3->4->5->NULL

    std::cout << "Linked List 1: ";
    printList(head1);

    if (hasLoop(head1)) {
        std::cout << "Linked List 1 has a loop." << std::endl;
    } else {
        std::cout << "Linked List 1 does not have a loop." << std::endl;
    }

    std::cout << "--------------------" << std::endl;

    // Example 2: Linked list with a loop
    Node* head2 = nullptr; // Initialize another empty linked list
    push(&head2, 5);
    push(&head2, 4);
    push(&head2, 3);
    push(&head2, 2);
    push(&head2, 1); // List: 1->2->3->4->5->NULL

    // Create a loop: Make the last node point to the third node (data 3)
    Node* current = head2;
    Node* node_with_data_3 = nullptr;
    Node* last_node = nullptr;

    while(current != nullptr) {
        if (current->data == 3) {
            node_with_data_3 = current;
        }
        if (current->next == nullptr) {
            last_node = current;
        }
        current = current->next;
    }

    if (last_node != nullptr && node_with_data_3 != nullptr) {
        last_node->next = node_with_data_3; // Create the loop
        std::cout << "Created a loop in Linked List 2 (5 points to 3)." << std::endl;
    }


    std::cout << "Linked List 2 (may show partial list due to loop): ";
    printList(head2);


    if (hasLoop(head2)) {
        std::cout << "Linked List 2 has a loop." << std::endl;
    } else {
        std::cout << "Linked List 2 does not have a loop." << std::endl;
    }

    // Clean up allocated memory (only for lists without loops in this simplified example)
    deleteList(&head1);

    // Note: Deleting head2 would require breaking the loop first.
    // For demonstration, we will not delete head2 in this example to keep it simple.


    return 0; // Indicate successful program execution
}





Given a sorted doubly linked list and a value to insert, write a function to insert the value
in a sorted way. Initial doubly linked list

#include <iostream> // Required for input/output operations like std::cout

// Define a structure for a node in the doubly linked list
struct Node {
    int data;   // Value stored in the node
    Node* prev; // Pointer to the previous node in the list
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to insert a new node in a sorted doubly linked list
// head_ref: Pointer to the pointer of the head of the linked list
// value: The value to insert
void insertSorted(Node** head_ref, int value) {
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // Case 1: If the list is empty
    if (*head_ref == nullptr) {
        *head_ref = newNode; // The new node becomes the head
        std::cout << "Inserted " << value << " into an empty list." << std::endl;
        return;
    }

    // Case 2: If the new node should be inserted before the head
    // (i.e., the new value is smaller than or equal to the head's data)
    if (value <= (*head_ref)->data) {
        newNode->next = *head_ref; // Link the new node to the current head
        (*head_ref)->prev = newNode; // Link the current head's prev to the new node
        *head_ref = newNode;       // Update the head to the new node
        std::cout << "Inserted " << value << " at the beginning." << std::endl;
        return;
    }

    // Case 3: Find the appropriate position to insert the new node
    Node* current = *head_ref;

    // Traverse the list to find the node after which the new node should be inserted
    // We stop when current->next is nullptr (end of list) OR
    // when the new value is less than or equal to the data of the next node.
    while (current->next != nullptr && current->next->data < value) {
        current = current->next;
    }

    // At this point, the new node should be inserted after 'current'.

    // Link the new node:
    newNode->next = current->next; // New node's next points to current's next
    newNode->prev = current;       // New node's prev points to current

    // Link the neighbors to the new node:
    if (current->next != nullptr) {
        current->next->prev = newNode; // If current's next exists, its prev points to new node
    }
    current->next = newNode;       // Current's next points to the new node

    std::cout << "Inserted " << value << " in the middle or at the end." << std::endl;
}

// Helper function to insert a new node at the beginning of the doubly linked list
// This is a helper function to easily build the initial linked list.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* new_node = new Node(new_data);

    // Point the next of the new node to the current head
    new_node->next = (*head_ref);

    // If the list is not empty, update the prev pointer of the old head
    if ((*head_ref) != nullptr) {
        (*head_ref)->prev = new_node;
    }

    // Move the head to point to the new node
    (*head_ref) = new_node;
}


// Helper function to print the doubly linked list elements
void printList(Node* node) {
    if (node == nullptr) {
        std::cout << "List is empty." << std::endl;
        return;
    }
    std::cout << "Doubly Linked List (Head to Tail): ";
    Node* last = nullptr; // Keep track of the last node for reverse printing (optional)
    while (node != nullptr) {
        std::cout << node->data << (node->next == nullptr ? "" : " <-> ");
        last = node; // Update last node
        node = node->next;
    }
    std::cout << std::endl;

    // Optional: Print in reverse to verify prev pointers
    // std::cout << "Doubly Linked List (Tail to Head): ";
    // while (last != nullptr) {
    //     std::cout << last->data << (last->prev == nullptr ? "" : " <-> ");
    //     last = last->prev;
    // }
    // std::cout << std::endl;
}

// Helper function to delete the doubly linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    Node* current = *head_ref;
    Node* next_node = nullptr;
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
    std::cout << "List deleted. Memory freed." << std::endl;
}


// Main function to demonstrate the insertSorted functionality
int main() {
    // Create an initial sorted doubly linked list
    // Example: 10 <-> 20 <-> 30 <-> 40 <-> 50
    Node* head = nullptr; // Initialize an empty list

    // Build the initial sorted list (pushing to front in reverse order)
    push(&head, 50);
    push(&head, 40);
    push(&head, 30);
    push(&head, 20);
    push(&head, 10);

    std::cout << "Initial Sorted Doubly Linked List:" << std::endl;
    printList(head);

    std::cout << "\nInserting elements:" << std::endl;

    // Insert values in a sorted manner
    insertSorted(&head, 25); // Insert in the middle
    printList(head);

    insertSorted(&head, 5);  // Insert at the beginning
    printList(head);

    insertSorted(&head, 60); // Insert at the end
    printList(head);

    insertSorted(&head, 30); // Insert a duplicate (should be inserted after the existing 30)
    printList(head);

    insertSorted(&head, 15); // Insert in the middle
    printList(head);

    insertSorted(&head, 0);  // Insert at the very beginning
    printList(head);


    // Clean up allocated memory
    deleteList(&head);

    return 0; // Indicate successful program execution
}





Given a circular doubly linked list and a position n. The task is to delete the node at the
given position n from the beginning. Initial circular doubly linked list.

#include <iostream> // Required for input/output operations like std::cout, std::cerr

// Define a structure for a node in the circular doubly linked list
struct Node {
    int data;   // Value stored in the node
    Node* prev; // Pointer to the previous node in the list
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to insert a new node at the beginning of a circular doubly linked list
// This is a helper function to easily build the initial linked list.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* newNode = new Node(new_data);

    // If the list is empty
    if (*head_ref == nullptr) {
        newNode->next = newNode; // Point next to itself
        newNode->prev = newNode; // Point prev to itself
        *head_ref = newNode;     // The new node is the head
        std::cout << "Pushed " << new_data << " into an empty list." << std::endl;
        return;
    }

    // If the list is not empty, insert the new node at the beginning
    Node* last = (*head_ref)->prev; // Get the last node

    newNode->next = *head_ref; // New node's next points to the current head
    newNode->prev = last;      // New node's prev points to the last node

    (*head_ref)->prev = newNode; // Current head's prev points to the new node
    last->next = newNode;      // Last node's next points to the new node

    *head_ref = newNode;       // Update the head to the new node

    std::cout << "Pushed " << new_data << " at the beginning." << std::endl;
}

// Function to print the circular doubly linked list elements
// Prints up to a certain limit to avoid infinite loops on unexpected structures.
void printList(Node* head, int limit = 20) {
    if (head == nullptr) {
        std::cout << "List is empty." << std::endl;
        return;
    }

    Node* current = head;
    int count = 0;

    std::cout << "Circular Doubly Linked List (Head to Tail, limited): ";
    do {
        std::cout << current->data << (current->next == head || count == limit - 1 ? "" : " <-> ");
        current = current->next;
        count++;
    } while (current != head && count < limit);

    if (count == limit && current != head) {
        std::cout << " ..." << std::endl; // Indicate potentially more elements
    } else {
         std::cout << " (back to head)" << std::endl; // Indicate circular nature
    }
}

// Function to delete the node at a given position n from the beginning
// head_ref: Pointer to the pointer of the head of the linked list
// n: The position of the node to delete (1-based index)
void deleteNodeAtPosition(Node** head_ref, int n) {
    // If the list is empty
    if (*head_ref == nullptr) {
        std::cerr << "Error: Cannot delete from an empty list." << std::endl;
        return;
    }

    // Get the size of the list
    int size = 0;
    Node* temp = *head_ref;
    if (temp != nullptr) {
        do {
            size++;
            temp = temp->next;
        } while (temp != *head_ref);
    }

    // Check if the position is valid
    if (n < 1 || n > size) {
        std::cerr << "Error: Invalid position " << n << ". Position must be between 1 and " << size << "." << std::endl;
        return;
    }

    Node* node_to_delete = *head_ref;

    // Case 1: Deleting the head node (n = 1)
    if (n == 1) {
        // If it's the only node
        if (size == 1) {
            delete *head_ref;
            *head_ref = nullptr; // List becomes empty
        }
        // If there are multiple nodes
        else {
            Node* last_node = (*head_ref)->prev; // Get the last node
            *head_ref = (*head_ref)->next;       // Move head to the next node
            last_node->next = *head_ref;         // Last node's next points to the new head
            (*head_ref)->prev = last_node;       // New head's prev points to the last node
            delete node_to_delete;               // Delete the original head
        }
        std::cout << "Deleted node at position " << n << "." << std::endl;
        return;
    }

    // Case 2: Deleting a node at position n > 1
    // Traverse to the node at position n-1
    Node* current = *head_ref;
    for (int i = 1; i < n - 1; ++i) {
        current = current->next;
    }

    // 'current' is now at position n-1
    node_to_delete = current->next; // The node to delete is at position n
    Node* next_node = node_to_delete->next; // The node after the one to delete

    // Adjust pointers to bypass the node to delete
    current->next = next_node;
    next_node->prev = current;

    // Delete the node
    delete node_to_delete;

    std::cout << "Deleted node at position " << n << "." << std::endl;
}

// Helper function to delete the entire circular doubly linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    if (*head_ref == nullptr) {
        std::cout << "List is already empty. Nothing to delete." << std::endl;
        return;
    }

    Node* current = *head_ref;
    Node* next_node = nullptr;
    Node* last = (*head_ref)->prev; // Get the last node

    // Break the circular link temporarily for safe traversal and deletion
    last->next = nullptr;

    // Traverse and delete nodes
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
    std::cout << "List deleted. Memory freed." << std::endl;
}


// Main function to demonstrate the deleteNodeAtPosition functionality
int main() {
    // Create an initial circular doubly linked list
    // Example: 10 <-> 20 <-> 30 <-> 40 <-> 50 (circular)
    Node* head = nullptr; // Initialize an empty list

    // Build the initial list (pushing to front)
    push(&head, 50);
    push(&head, 40);
    push(&head, 30);
    push(&head, 20);
    push(&head, 10);

    std::cout << "Initial Circular Doubly Linked List:" << std::endl;
    printList(head);

    std::cout << "\nDeleting nodes:" << std::endl;

    // Delete node at position 3 (which is 30)
    deleteNodeAtPosition(&head, 3);
    printList(head);

    // Delete node at position 1 (the new head, which is 10)
    deleteNodeAtPosition(&head, 1);
    printList(head);

    // Delete node at the new last position (which is 50)
    // Need to find the size first to know the last position
    int current_size = 0;
     if (head != nullptr) {
        Node* temp = head;
        do {
            current_size++;
            temp = temp->next;
        } while (temp != head);
    }
    deleteNodeAtPosition(&head, current_size); // Delete the last node
    printList(head);

    // Delete remaining nodes
    deleteNodeAtPosition(&head, 1); // Delete current head (20)
    printList(head);
    deleteNodeAtPosition(&head, 1); // Delete current head (40)
    printList(head);

    // Attempt to delete from an empty list
    deleteNodeAtPosition(&head, 1);

    // Clean up allocated memory (even though we deleted nodes individually,
    // this ensures cleanup if the list wasn't fully emptied)
    deleteList(&head);

    return 0; // Indicate successful program execution
}





Given a sorted circular doubly linked list of distinct nodes(no two nodes have the same
data) and a value x. Count triplets in the list that sum up to a given value x.

#include <iostream> // Required for input/output operations like std::cout, std::cerr

// Define a structure for a node in the circular doubly linked list
struct Node {
    int data;   // Value stored in the node
    Node* prev; // Pointer to the previous node in the list
    Node* next; // Pointer to the next node in the list

    // Constructor to create a new node
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Function to insert a new node at the beginning of a circular doubly linked list
// This is a helper function to easily build the initial linked list.
// Assumes the list is being built in sorted order for the triplet counting function.
void push(Node** head_ref, int new_data) {
    // Create a new node with the given data
    Node* newNode = new Node(new_data);

    // If the list is empty
    if (*head_ref == nullptr) {
        newNode->next = newNode; // Point next to itself
        newNode->prev = newNode; // Point prev to itself
        *head_ref = newNode;     // The new node is the head
        // std::cout << "Pushed " << new_data << " into an empty list." << std::endl;
        return;
    }

    // If the list is not empty, insert the new node at the beginning
    Node* last = (*head_ref)->prev; // Get the last node

    newNode->next = *head_ref; // New node's next points to the current head
    newNode->prev = last;      // New node's prev points to the last node

    (*head_ref)->prev = newNode; // Current head's prev points to the new node
    last->next = newNode;      // Last node's next points to the new node

    *head_ref = newNode;       // Update the head to the new node

    // std::cout << "Pushed " << new_data << " at the beginning." << std::endl;
}

// Function to print the circular doubly linked list elements
// Prints up to a certain limit to avoid infinite loops on unexpected structures.
void printList(Node* head, int limit = 20) {
    if (head == nullptr) {
        std::cout << "List is empty." << std::endl;
        return;
    }

    Node* current = head;
    int count = 0;

    std::cout << "Circular Doubly Linked List (Head to Tail, limited): ";
    do {
        std::cout << current->data << (current->next == head || count == limit - 1 ? "" : " <-> ");
        current = current->next;
        count++;
    } while (current != head && count < limit);

    if (count == limit && current != head) {
        std::cout << " ..." << std::endl; // Indicate potentially more elements
    } else {
         std::cout << " (back to head)" << std::endl; // Indicate circular nature
    }
}

// Function to count triplets in a sorted circular doubly linked list that sum up to a given value x
// head: Pointer to the head of the linked list
// x: The target sum
int countTriplets(Node* head, int x) {
    // If the list is empty or has fewer than 3 nodes, no triplets can be formed
    if (head == nullptr || head->next == head || head->next->next == head) {
        return 0;
    }

    int count = 0;
    Node* ptr1 = head;

    // Iterate ptr1 through each node in the list.
    // This node will be the first element of a potential triplet.
    do {
        // Initialize ptr2 to the node after ptr1 and ptr3 to the node before ptr1 (the tail).
        // These two pointers will search for the remaining sum (x - ptr1->data).
        Node* ptr2 = ptr1->next;
        Node* ptr3 = ptr1->prev;

        // Use two pointers ptr2 and ptr3 to find pairs that sum up to (x - ptr1->data).
        // The loop continues as long as ptr2 and ptr3 haven't crossed each other
        // and are not the same node.
        // The condition `ptr2 != ptr3 && ptr3->next != ptr2` checks for crossing/meeting.
        while (ptr2 != ptr3 && ptr3->next != ptr2) {
             // Ensure ptr2 and ptr3 are not the same node as ptr1.
             // This is important in a circular list as pointers wrap around.
             if (ptr2 == ptr1 || ptr3 == ptr1) break;

            int current_sum = ptr1->data + ptr2->data + ptr3->data;

            if (current_sum == x) {
                // Found a triplet that sums up to x
                count++;
                // Move both pointers inwards to find other potential pairs for ptr1.
                // Since the list is sorted, moving inwards explores different sums.
                ptr2 = ptr2->next;
                ptr3 = ptr3->prev;
            } else if (current_sum < x) {
                // The current sum is too small, need a larger sum.
                // Move ptr2 forward to a potentially larger value.
                ptr2 = ptr2->next;
            } else { // current_sum > x
                // The current sum is too large, need a smaller sum.
                // Move ptr3 backward to a potentially smaller value.
                ptr3 = ptr3->prev;
            }
        }
        ptr1 = ptr1->next; // Move ptr1 to the next node to consider it as the first element of the triplet.
    } while (ptr1 != head); // Continue until ptr1 wraps around back to the head, covering all possible first elements.

    return count;
}


// Helper function to delete the entire circular doubly linked list (to prevent memory leaks)
void deleteList(Node** head_ref) {
    if (*head_ref == nullptr) {
        std::cout << "List is already empty. Nothing to delete." << std::endl;
        return;
    }

    Node* current = *head_ref;
    Node* next_node = nullptr;
    Node* last = (*head_ref)->prev; // Get the last node

    // Break the circular link temporarily for safe traversal and deletion
    last->next = nullptr;

    // Traverse and delete nodes
    while (current != nullptr) {
        next_node = current->next;
        delete current;
        current = next_node;
    }
    *head_ref = nullptr; // Set head to null after deleting all nodes
    std::cout << "List deleted. Memory freed." << std::endl;
}


// Main function to demonstrate the countTriplets functionality
int main() {
    // Create a sorted circular doubly linked list with distinct nodes
    // Example: 1 <-> 2 <-> 4 <-> 5 <-> 8 <-> 9 (circular)
    Node* head = nullptr; // Initialize an empty list

    // Build the initial sorted list (pushing to front in reverse order)
    push(&head, 9);
    push(&head, 8);
    push(&head, 5);
    push(&head, 4);
    push(&head, 2);
    push(&head, 1);

    std::cout << "Initial Sorted Circular Doubly Linked List:" << std::endl;
    printList(head);

    // Target sum
    int target_sum = 17;
    std::cout << "\nTarget sum (x): " << target_sum << std::endl;

    // Count the triplets
    int triplet_count = countTriplets(head, target_sum);

    std::cout << "Number of triplets that sum up to " << target_sum << ": " << triplet_count << std::endl;
    // Expected triplets for sum 17: (1, 8, 8) - but nodes are distinct, so (1, 8, 8) is not possible.
    // (1, 9, 7) - 7 not in list
    // (2, 8, 7) - 7 not in list
    // (4, 5, 8) -> 4 + 5 + 8 = 17. This is a valid triplet.
    // (4, 9, 4) - 4 is distinct, so (4, 9, 4) is not possible.
    // (5, 8, 4) -> 5 + 8 + 4 = 17. Same triplet as (4, 5, 8), will be counted once.
    // (5, 9, 3) - 3 not in list
    // (8, 9, 0) - 0 not in list
    // Valid triplet is (4, 5, 8). Count should be 1.

    std::cout << "--------------------" << std::endl;

    // Another example
    Node* head2 = nullptr;
    push(&head2, 10);
    push(&head2, 8);
    push(&head2, 6);
    push(&head2, 4);
    push(&head2, 2);

    std::cout << "Another Sorted Circular Doubly Linked List:" << std::endl;
    printList(head2);

    int target_sum2 = 12;
    std::cout << "\nTarget sum (x): " << target_sum2 << std::endl;
    int triplet_count2 = countTriplets(head2, target_sum2);
    std::cout << "Number of triplets that sum up to " << target_sum2 << ": " << triplet_count2 << std::endl;
    // Expected triplets for sum 12:
    // (2, 4, 6) -> 2 + 4 + 6 = 12. Valid.
    // (2, ?)
    // (4, ?)
    // (6, ?)
    // (8, ?)
    // (10, ?)
    // Valid triplet is (2, 4, 6). Count should be 1.


    // Clean up allocated memory
    deleteList(&head);
    deleteList(&head2);

    return 0; // Indicate successful program execution
}
